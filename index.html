<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Sheets 데이터 뷰어 (자동 로드)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <div class="bg-white rounded-2xl shadow-lg p-6 md:p-8">
            <header class="mb-6">
                <h1 class="text-3xl sm:text-4xl font-bold text-gray-900 mb-2">Google Sheets 데이터 뷰어</h1>
                <p class="text-gray-600">지정된 스프레드시트의 데이터를 필터링합니다.</p>
            </header>

            <!-- 동적 필터 컨트롤이 생성될 영역 -->
            <div id="filter-controls" class="hidden my-4 p-4 bg-gray-50 rounded-lg border">
                <div id="dynamic-filter-area" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    <!-- Filter dropdowns will be populated by JS -->
                </div>
            </div>

            <!-- 데이터가 표시될 컨테이너 -->
            <div id="data-container" class="overflow-x-auto">
                 <div id="loading-state" class="text-center py-10">
                    <div class="loader mx-auto mb-4"></div>
                    <p class="text-gray-500">데이터를 불러오는 중입니다...</p>
                </div>
            </div>
             <!-- 에러 메시지 표시 영역 -->
            <div id="error-message" class="hidden mt-4 p-4 bg-red-100 text-red-700 border border-red-200 rounded-lg"></div>
        </div>
    </div>

    <script>
        const dataContainer = document.getElementById('data-container');
        const errorMessageDiv = document.getElementById('error-message');
        const filterControls = document.getElementById('filter-controls');
        const dynamicFilterArea = document.getElementById('dynamic-filter-area');

        // *** 여기에 자신의 구글 시트 .csv 게시 URL을 붙여넣으세요! ***
        const SPREADSHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTHoZSL8BubqCrnl8C-6YHBCwizDHLGjSFuj4M7eSFuCfA1AXjQvue78U3gSw3p_TbPwaFjADEsShHN/pub?gid=0&single=true&output=csv';

        let fullData = [];

        // 페이지가 로드되면 자동으로 데이터를 불러옵니다.
        window.addEventListener('DOMContentLoaded', () => {
            if (!SPREADSHEET_URL) {
                displayError('연결할 스프레드시트 URL이 코드에 지정되지 않았습니다.');
                return;
            }
            fetchSheetData(SPREADSHEET_URL);
        });

        async function fetchSheetData(googleSheetUrl) {
            errorMessageDiv.classList.add('hidden');
            filterControls.classList.add('hidden');
            dynamicFilterArea.innerHTML = '';

            try {
                const response = await fetch(googleSheetUrl);
                if (!response.ok) throw new Error(`데이터를 불러오는 데 실패했습니다. (상태 코드: ${response.status})`);
                
                const csvData = await response.text();
                const parsedData = parseCSV(csvData);
                
                if (parsedData.length < 2) throw new Error('스프레드시트에 표시할 데이터가 없습니다.');
                
                fullData = parsedData;
                displayDataAsTable(fullData);
                populateDynamicFilters(fullData[0], fullData.slice(1));

            } catch (error) {
                console.error('Error fetching or parsing data:', error);
                displayError(`오류가 발생했습니다: ${error.message}.`);
            }
        }

        function parseCSV(csvText) {
            const rows = csvText.trim().split(/\r?\n/);
            return rows.map(row => {
                const results = [];
                let current = '';
                let inQuote = false;
                for (let i = 0; i < row.length; i++) {
                    const char = row[i];
                    if (char === '"' && (i === 0 || row[i-1] !== '\\')) {
                        inQuote = !inQuote;
                    } else if (char === ',' && !inQuote) {
                        results.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                results.push(current.trim());
                return results;
            });
        }
        
        function displayDataAsTable(data) {
            const headers = data[0];
            const rows = data.slice(1);

            let tableBodyHTML = rows.length > 0 ? rows.map(row => `
                <tr class="text-gray-700 hover:bg-gray-50">
                    ${row.map(cell => `<td class="px-4 py-3 text-sm">${cell}</td>`).join('')}
                </tr>
            `).join('') : `
                <tr>
                    <td colspan="${headers.length}" class="px-4 py-4 text-center text-gray-500">
                        선택과 일치하는 데이터가 없습니다.
                    </td>
                </tr>`;

            const tableHTML = `
                <div class="w-full overflow-hidden rounded-lg shadow-md">
                    <table class="w-full whitespace-nowrap">
                        <thead class="bg-gray-100">
                            <tr class="text-left text-sm font-semibold text-gray-600 uppercase tracking-wider">
                                ${headers.map(header => `<th class="px-4 py-3">${header}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">${tableBodyHTML}</tbody>
                    </table>
                </div>`;
            dataContainer.innerHTML = tableHTML;
        }

        function populateDynamicFilters(headers, dataRows) {
            dynamicFilterArea.innerHTML = ''; // Clear previous filters

            headers.forEach((header, index) => {
                if (!header) return;

                const uniqueValues = [...new Set(dataRows.map(row => row[index]))]
                    .filter(Boolean)
                    .sort();

                if (uniqueValues.length > 0) {
                    const filterContainer = document.createElement('div');
                    
                    const label = document.createElement('label');
                    label.htmlFor = `filter-col-${index}`;
                    label.className = "block text-sm font-medium text-gray-700 mb-1";
                    label.textContent = header;
                    
                    const select = document.createElement('select');
                    select.id = `filter-col-${index}`;
                    select.dataset.columnIndex = index;
                    select.className = "w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white";
                    select.addEventListener('change', applyFilters);

                    select.innerHTML = `<option value="">전체 ${header}</option>`;
                    
                    uniqueValues.forEach(value => {
                        const option = document.createElement('option');
                        option.value = value;
                        option.textContent = value;
                        select.appendChild(option);
                    });

                    filterContainer.appendChild(label);
                    filterContainer.appendChild(select);
                    dynamicFilterArea.appendChild(filterContainer);
                }
            });

            if (dynamicFilterArea.children.length > 0) {
                filterControls.classList.remove('hidden');
            }
        }

        function applyFilters() {
            const filterSelects = document.querySelectorAll('#dynamic-filter-area select');
            const activeFilters = {};
            
            filterSelects.forEach(select => {
                if (select.value) {
                    activeFilters[select.dataset.columnIndex] = select.value;
                }
            });

            const headers = fullData[0];
            const dataRows = fullData.slice(1);

            const filteredRows = dataRows.filter(row => {
                return Object.entries(activeFilters).every(([columnIndex, filterValue]) => {
                    return row[columnIndex] === filterValue;
                });
            });

            displayDataAsTable([headers, ...filteredRows]);
        }

        function displayError(message) {
             dataContainer.innerHTML = '';
             errorMessageDiv.textContent = message;
             errorMessageDiv.classList.remove('hidden');
             filterControls.classList.add('hidden');
        }
    </script>

</body>
</html>

